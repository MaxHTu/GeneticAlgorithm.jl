var documenterSearchIndex = {"docs":
[{"location":"selection/#Selection","page":"Selection","title":"Selection","text":"","category":"section"},{"location":"selection/","page":"Selection","title":"Selection","text":"The Selection process chooses individuals from the population to be the parents to create the next generation. The goal is to select individuals with the highest fitness. This promotes the survival of the best solution.","category":"page"},{"location":"selection/#Selection-Functions","page":"Selection","title":"Selection Functions","text":"","category":"section"},{"location":"selection/","page":"Selection","title":"Selection","text":"tournament_selection","category":"page"},{"location":"selection/#GeneticAlgorithm.tournament_selection","page":"Selection","title":"GeneticAlgorithm.tournament_selection","text":"tournament_selection(population::Vector, fitness::Vector, tournamentSize::Int, num::Integer)\n\nSelect one unit with higher fitness over several tournament rounds with randomly chosen groups of unit from the population .\n\nArguments\n\npopulation: Population vector.\nfitness: Vector of fitness values.\ntournamentSize: Size of tournament groups.\nnum: Amount of genes to select\n\nReturns\n\nThe unit with better fitness value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Api","page":"Api","title":"Api","text":"","category":"section"},{"location":"api/","page":"Api","title":"Api","text":"solveRosenbrock","category":"page"},{"location":"api/#GeneticAlgorithm.solveRosenbrock","page":"Api","title":"GeneticAlgorithm.solveRosenbrock","text":"solveRosenbrock(;     a::Integer,     b::Integer,     popSize::Integer,     fitnessFunc::Function,     unitValues::Union{Type, AbstractVector{<:AbstractFloat}, AbstractRange{<:Real}},     unitShape::AbstractVector{<:Integer},     genNum::Integer,     crossRate::Real,     mutRate::Real,     nextGenAmt::Number,     selectionFunc::Function,     crossoverFunc::Function,     mutationFunc::Function ,     terminationNum::Real )\n\nRuns the rosenbrock function with the geneticAlgorithm\n\nArguments\n\na: rosenbrock function variable\nb: rosenbrock function variable\npopSize: Size of population.\nfitnessFunc: Fitness function.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\nnextGenAmt: amount of genes that are automatically copied to new generation\nselectionFunc: Selection function.\ncrossoverFunc: Crossover function.\nmutationFunc: Mutation function.\nterminationNum: number of iteration after which the algorithm aborts if there is no change in fitness value from the best gene\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Mutation","page":"Mutation","title":"Mutation","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"The Mutation function makes random changes to the genes of individuals, mimicking the process of genetic mutation in nature. This is essential to maintain diversity in the population and introduce new genes to the population.","category":"page"},{"location":"mutation/#Mutation-Functions","page":"Mutation","title":"Mutation Functions","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"","category":"page"},{"location":"crossover/#Crossover","page":"Crossover","title":"Crossover","text":"","category":"section"},{"location":"crossover/","page":"Crossover","title":"Crossover","text":"The Crossover function, also known as recombination, mimics the genetic recombination during natural evolution. It combines the genetic information(chromosomes) of the parents to create one or more new children. ","category":"page"},{"location":"crossover/#Crossover-Functions","page":"Crossover","title":"Crossover Functions","text":"","category":"section"},{"location":"crossover/","page":"Crossover","title":"Crossover","text":"single_point_crossover\nk_point_crossover\nuniform_crossover","category":"page"},{"location":"crossover/#GeneticAlgorithm.single_point_crossover","page":"Crossover","title":"GeneticAlgorithm.single_point_crossover","text":"single_point_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix})\n\nRecombinate two units by exchanging their genes from a random index onward.\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#GeneticAlgorithm.k_point_crossover","page":"Crossover","title":"GeneticAlgorithm.k_point_crossover","text":"k_point_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix}, k::Integer)\n\nRecombinate two units by exchanging their genes at k random points\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\nk: # of crossover points.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#GeneticAlgorithm.uniform_crossover","page":"Crossover","title":"GeneticAlgorithm.uniform_crossover","text":"uniform_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix})\n\nRecombinate two units by iterating a gene and swapping the values with a 50% chance\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"function"},{"location":"initialisation/#Initialisation","page":"Initialisation","title":"Initialisation","text":"","category":"section"},{"location":"initialisation/","page":"Initialisation","title":"Initialisation","text":"This is the starting point of a Genetic Algorithm. The Initialisation generates the initial population of individuals, which is usually generated randomly.","category":"page"},{"location":"initialisation/#Initialisation-Functions","page":"Initialisation","title":"Initialisation Functions","text":"","category":"section"},{"location":"initialisation/","page":"Initialisation","title":"Initialisation","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeneticAlgorithm","category":"page"},{"location":"#GeneticAlgorithm","page":"Home","title":"GeneticAlgorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package providing genetic algorithms for optimization. It provides diffrent implementation of mutation, recombination, crossover and selection functions. Documentation for GeneticAlgorithm.","category":"page"},{"location":"#Important","page":"Home","title":"Important","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is build for the Julia Programming for Machine Learning course at TU Berlin and will will not be maintained afterwards.","category":"page"},{"location":"#What-is-a-Genetic-Algorithm?","page":"Home","title":"What is a Genetic Algorithm?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Genetic Algorithm is a technique based on natural evolution and genetics. It solves constrained and unconstrained optimization problems in which traditional algorithms and methods might struggle. It is part of the class of evolutionary algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following chart shows the basic steps of a Genetic Algorithm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: How does a Genetic Algorithm work)","category":"page"},{"location":"#Outline-of-a-Genetic-Algorithm:","page":"Home","title":"Outline of a Genetic Algorithm:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initialisation: creates the initial population of individuals with random chromosomes\nEvaluation: evaluate the fitness of each individual using the fitness function\nSelection: select the best individuals based on their fitness score to select parents for the new generation\nCrossover: the selected parents are combined to produce offspring\nMutation: some chromosomes are mutated\nRepeat: repeat this the Evaluation, Selection, Crossover, and Mutation until a solution is found or the termination condition is met","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/MaxHTu/GeneticAlgorithm.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a simple example unsing a genetic algorithm to solve he Rosenbrock function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeneticAlgorithm\ngenAlgo(50, true, 2, rosenbrock, 50, 0.25, 0.1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"geneticAlgorithm\ngenAlgo","category":"page"},{"location":"#GeneticAlgorithm.geneticAlgorithm","page":"Home","title":"GeneticAlgorithm.geneticAlgorithm","text":"geneticAlgorithm(     popSize::Integer,     unitValues::Type,     unitShape::Integer,     fitnessFunc::Function,     genNum::Integer,     selection::Function,     crossover::Function,     mutation::Function,     crossRate::Real,     mutRate::Real,     nextGenAmt::Real,     terminationNum::Real;     initFunc::Function )\n\nEvolve the population of units for a specified number of generations. The loop creates a new population every generation by selecting units with higher fitness, recombinating and mutating them until the old population can be replaced by a fitter one.\n\nArguments\n\nfitnessFunc: Fitness function.\npopSize: Size of population.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\nselection: Selection function.\ncrossover: Crossover function.\nmutation: Mutation function.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\nnextGenAmt: amount of genes that are automatically copied to new generation\nterminationNum: number of iteration after which the algorithm aborts if there is no change in fitness value from the best gene\ninitFunc: function to generate initial population\n\n\n\n\n\n","category":"function"},{"location":"#GeneticAlgorithm.genAlgo","page":"Home","title":"GeneticAlgorithm.genAlgo","text":"genAlgo(     popSize::Integer,     unitValues::Type,     unitShape::Integer,     fitnessFunc::Function,     genNum::Integer,     selection::Function,     crossover::Function,     mutation::Function,     crossRate::Real,     mutRate::Real )\n\nTODO: description\n\nArguments\n\nfitnessFunc: Fitness function.\npopSize: Size of population.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\nselection: Selection function.\ncrossover: Crossover function.\nmutation: Mutation function.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Modules = [GeneticAlgorithm]","category":"page"},{"location":"#GeneticAlgorithm.binarystring-Tuple{AbstractVector}","page":"Home","title":"GeneticAlgorithm.binarystring","text":"binarystring(x)\n\nCompute the fitness of a binary string unit.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe digit sum of input vector.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.default_selection-Tuple{Union{AbstractMatrix, AbstractVector}, Integer}","page":"Home","title":"GeneticAlgorithm.default_selection","text":"default_selection(population::Union{AbstractVector,AbstractMatrix}, num::Integer)\n\nSelects a specified number of individuals from a population.\n\nArguments\n\npopulation: The population from which individuals will be selected.\nnum: The number of individuals to select.\n\nReturns\n\nAn array of selected individuals.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.genAlgo-Tuple{Function, Integer, Union{Type, AbstractVector{<:Real}}, AbstractVector{<:Integer}, Integer, Function, Function, Function, Vararg{Real, 4}}","page":"Home","title":"GeneticAlgorithm.genAlgo","text":"genAlgo(     popSize::Integer,     unitValues::Type,     unitShape::Integer,     fitnessFunc::Function,     genNum::Integer,     selection::Function,     crossover::Function,     mutation::Function,     crossRate::Real,     mutRate::Real )\n\nTODO: description\n\nArguments\n\nfitnessFunc: Fitness function.\npopSize: Size of population.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\nselection: Selection function.\ncrossover: Crossover function.\nmutation: Mutation function.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.geneticAlgorithm-Tuple{Function, Integer, Union{Type, AbstractVector{<:Real}}, AbstractVector{<:Integer}, Integer, Function, Function, Function, Vararg{Real, 4}}","page":"Home","title":"GeneticAlgorithm.geneticAlgorithm","text":"geneticAlgorithm(     popSize::Integer,     unitValues::Type,     unitShape::Integer,     fitnessFunc::Function,     genNum::Integer,     selection::Function,     crossover::Function,     mutation::Function,     crossRate::Real,     mutRate::Real,     nextGenAmt::Real,     terminationNum::Real;     initFunc::Function )\n\nEvolve the population of units for a specified number of generations. The loop creates a new population every generation by selecting units with higher fitness, recombinating and mutating them until the old population can be replaced by a fitter one.\n\nArguments\n\nfitnessFunc: Fitness function.\npopSize: Size of population.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\nselection: Selection function.\ncrossover: Crossover function.\nmutation: Mutation function.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\nnextGenAmt: amount of genes that are automatically copied to new generation\nterminationNum: number of iteration after which the algorithm aborts if there is no change in fitness value from the best gene\ninitFunc: function to generate initial population\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.griewank-Tuple{AbstractVector{<:Number}}","page":"Home","title":"GeneticAlgorithm.griewank","text":"griewank(x)\n\nCompute the Griewank function value for a given input vector x.\n\nThe Griewank function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as the difference between two terms: the sum of the squares of each element in x divided by 4000, and the product of the cosine of each element in x divided by the square root of its index.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Griewank function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.k_point_crossover-Tuple{Union{AbstractMatrix, AbstractVector}, Union{AbstractMatrix, AbstractVector}, Integer}","page":"Home","title":"GeneticAlgorithm.k_point_crossover","text":"k_point_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix}, k::Integer)\n\nRecombinate two units by exchanging their genes at k random points\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\nk: # of crossover points.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.mutation!-Tuple{Union{AbstractMatrix{<:Real}, AbstractVector{<:Real}}, Real, Union{Type, AbstractVector{<:Real}}}","page":"Home","title":"GeneticAlgorithm.mutation!","text":"mutation!(gene, mutation_prob, unitValues)\n\nMutates the given gene based on the mutation_prob and unitValues.\n\nArguments\n\ngene: A matrix or vector containing real numbers or boolean values.\nmutation_prob: The probability of mutation for each element in the gene.\nunitValues: A type or vector representing the range of values for mutation.\n\nDetails\n\nFor each element in the gene, if a random number is less than mutation_prob, the element is mutated.\nIf unitValues is an abstract range of floating-point numbers, the mutated element is transformed to fit within the range.\nIf unitValues is a vector of boolean values, the mutated element is negated.\nOtherwise, the mutated element is replaced with a random value from unitValues.\n\nReturns\n\nThe mutated gene.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.quartic-Tuple{AbstractVector{<:Number}}","page":"Home","title":"GeneticAlgorithm.quartic","text":"quartic(x)\n\nCompute the quartic function value for a given input vector x.\n\nThe quartic function is defined as the sum of the product of each element in x raised to the power of 4 and its index, plus a random number.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe quartic function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.rastrigin-Tuple{AbstractVector{<:Number}}","page":"Home","title":"GeneticAlgorithm.rastrigin","text":"rastrigin(x)\n\nCompute the Rastrigin function value for a given input vector x.\n\nThe Rastrigin function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as a sum of terms involving the square of each element in x, minus 10 times the cosine of 2π times each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Rastrigin function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.rosenbrock-Tuple{Vector{<:Number}}","page":"Home","title":"GeneticAlgorithm.rosenbrock","text":"rosenbrock(x)\n\nCompute the Rosenbrock function value for a given input vector x.\n\nThe Rosenbrock function is a non-convex function used as a performance test problem for optimization algorithms. It is defined as the sum of a series of terms involving the squares of differences between adjacent elements of x.\n\nArguments\n\nx: Input vector.\na: value for the variable a\nb: value for the variable b\n\nReturns\n\nThe Rosenbrock function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.schwefel-Tuple{AbstractVector{<:Number}}","page":"Home","title":"GeneticAlgorithm.schwefel","text":"schwefel(x)\n\nCompute the Schwefel function value for a given input vector x.\n\nThe Schwefel function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as a sum of terms involving the sine function and the square root of the absolute value of each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Schwefel function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.single_point_crossover-Tuple{Union{AbstractMatrix, AbstractVector}, Union{AbstractMatrix, AbstractVector}}","page":"Home","title":"GeneticAlgorithm.single_point_crossover","text":"single_point_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix})\n\nRecombinate two units by exchanging their genes from a random index onward.\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.solveRosenbrock-Tuple{}","page":"Home","title":"GeneticAlgorithm.solveRosenbrock","text":"solveRosenbrock(;     a::Integer,     b::Integer,     popSize::Integer,     fitnessFunc::Function,     unitValues::Union{Type, AbstractVector{<:AbstractFloat}, AbstractRange{<:Real}},     unitShape::AbstractVector{<:Integer},     genNum::Integer,     crossRate::Real,     mutRate::Real,     nextGenAmt::Number,     selectionFunc::Function,     crossoverFunc::Function,     mutationFunc::Function ,     terminationNum::Real )\n\nRuns the rosenbrock function with the geneticAlgorithm\n\nArguments\n\na: rosenbrock function variable\nb: rosenbrock function variable\npopSize: Size of population.\nfitnessFunc: Fitness function.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\nnextGenAmt: amount of genes that are automatically copied to new generation\nselectionFunc: Selection function.\ncrossoverFunc: Crossover function.\nmutationFunc: Mutation function.\nterminationNum: number of iteration after which the algorithm aborts if there is no change in fitness value from the best gene\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.sphere-Tuple{Vector{<:Number}}","page":"Home","title":"GeneticAlgorithm.sphere","text":"sphere(x)\n\nCompute the sphere function value for a given input vector x.\n\nThe sphere function is defined as the sum of the squares of each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe sphere function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.tournament_selection-Tuple{AbstractVector, AbstractVector, Integer}","page":"Home","title":"GeneticAlgorithm.tournament_selection","text":"tournament_selection(population::Vector, fitness::Vector, tournamentSize::Int, num::Integer)\n\nSelect one unit with higher fitness over several tournament rounds with randomly chosen groups of unit from the population .\n\nArguments\n\npopulation: Population vector.\nfitness: Vector of fitness values.\ntournamentSize: Size of tournament groups.\nnum: Amount of genes to select\n\nReturns\n\nThe unit with better fitness value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.uniform_crossover-Tuple{Union{AbstractMatrix, AbstractVector}, Union{AbstractMatrix, AbstractVector}}","page":"Home","title":"GeneticAlgorithm.uniform_crossover","text":"uniform_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix})\n\nRecombinate two units by iterating a gene and swapping the values with a 50% chance\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.weighted_selection-Tuple{AbstractVector, AbstractVector, Integer}","page":"Home","title":"GeneticAlgorithm.weighted_selection","text":"weighted_selection(population::Vector, fitness::Vector, num::Integer)\n\nSelect num random genes from population weight by the fitness of the genes\n\nArguments\n\npopulation: Population vector.\nfitness: Vector of fitness values.\nnum: Amount of genes to select\n\nReturns\n\nnum selected genes\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#Evaluation","page":"Evaluation","title":"Evaluation","text":"","category":"section"},{"location":"evaluation/","page":"Evaluation","title":"Evaluation","text":"This file contains a collection of common optimization test functions implemented in Julia to test the performance of the Genetic Algorithm. The functions are based on the paper ON BENCHMARKING FUNCTIONS FOR GENETIC ALGORITHMS.","category":"page"},{"location":"evaluation/","page":"Evaluation","title":"Evaluation","text":"sphere\nrosenbrock\nquartic\nschwefel\nrastrigin\ngriewank\nbinarystring","category":"page"},{"location":"evaluation/#GeneticAlgorithm.sphere","page":"Evaluation","title":"GeneticAlgorithm.sphere","text":"sphere(x)\n\nCompute the sphere function value for a given input vector x.\n\nThe sphere function is defined as the sum of the squares of each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe sphere function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.rosenbrock","page":"Evaluation","title":"GeneticAlgorithm.rosenbrock","text":"rosenbrock(x)\n\nCompute the Rosenbrock function value for a given input vector x.\n\nThe Rosenbrock function is a non-convex function used as a performance test problem for optimization algorithms. It is defined as the sum of a series of terms involving the squares of differences between adjacent elements of x.\n\nArguments\n\nx: Input vector.\na: value for the variable a\nb: value for the variable b\n\nReturns\n\nThe Rosenbrock function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.quartic","page":"Evaluation","title":"GeneticAlgorithm.quartic","text":"quartic(x)\n\nCompute the quartic function value for a given input vector x.\n\nThe quartic function is defined as the sum of the product of each element in x raised to the power of 4 and its index, plus a random number.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe quartic function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.schwefel","page":"Evaluation","title":"GeneticAlgorithm.schwefel","text":"schwefel(x)\n\nCompute the Schwefel function value for a given input vector x.\n\nThe Schwefel function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as a sum of terms involving the sine function and the square root of the absolute value of each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Schwefel function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.rastrigin","page":"Evaluation","title":"GeneticAlgorithm.rastrigin","text":"rastrigin(x)\n\nCompute the Rastrigin function value for a given input vector x.\n\nThe Rastrigin function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as a sum of terms involving the square of each element in x, minus 10 times the cosine of 2π times each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Rastrigin function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.griewank","page":"Evaluation","title":"GeneticAlgorithm.griewank","text":"griewank(x)\n\nCompute the Griewank function value for a given input vector x.\n\nThe Griewank function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as the difference between two terms: the sum of the squares of each element in x divided by 4000, and the product of the cosine of each element in x divided by the square root of its index.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Griewank function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.binarystring","page":"Evaluation","title":"GeneticAlgorithm.binarystring","text":"binarystring(x)\n\nCompute the fitness of a binary string unit.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe digit sum of input vector.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Tuturial","page":"Tutorial","title":"Tuturial","text":"","category":"section"}]
}
