var documenterSearchIndex = {"docs":
[{"location":"selection/#Selection","page":"Selection","title":"Selection","text":"","category":"section"},{"location":"selection/","page":"Selection","title":"Selection","text":"The Selection process chooses individuals from the population to be the parents to create the next generation. The goal is to select individuals with the highest fitness. This promotes the survival of the best solution.","category":"page"},{"location":"selection/#Selection-Functions","page":"Selection","title":"Selection Functions","text":"","category":"section"},{"location":"selection/","page":"Selection","title":"Selection","text":"tournament_selection","category":"page"},{"location":"selection/#GeneticAlgorithm.tournament_selection","page":"Selection","title":"GeneticAlgorithm.tournament_selection","text":"tournament_selection(population::Vector, fitness::Vector, tournamentSize::Int, num::Integer)\n\nSelect one unit with higher fitness over several tournament rounds with randomly chosen groups of unit from the population .\n\nArguments\n\npopulation: Population vector.\nfitness: Vector of fitness values.\ntournamentSize: Size of tournament groups.\nnum: Amount of genes to select\n\nReturns\n\nThe unit with better fitness value.\n\n\n\n\n\n","category":"function"},{"location":"api/#Api","page":"Api","title":"Api","text":"","category":"section"},{"location":"api/","page":"Api","title":"Api","text":"solveRosenbrock","category":"page"},{"location":"api/#GeneticAlgorithm.solveRosenbrock","page":"Api","title":"GeneticAlgorithm.solveRosenbrock","text":"solveRosenbrock(;     a::Integer,     b::Integer,     popSize::Integer,     fitnessFunc::Function,     unitValues::Union{Type, AbstractVector{<:AbstractFloat}, AbstractRange{<:Real}},     unitShape::AbstractVector{<:Integer},     genNum::Integer,     crossRate::Real,     mutRate::Real,     nextGenAmt::Number,     selectionFunc::Function,     crossoverFunc::Function,     mutationFunc::Function ,     terminationNum::Real )\n\nRuns the rosenbrock function with the geneticAlgorithm\n\nArguments\n\na: rosenbrock function variable\nb: rosenbrock function variable\npopSize: Size of population.\nfitnessFunc: Fitness function.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\nnextGenAmt: amount of genes that are automatically copied to new generation\nselectionFunc: Selection function.\ncrossoverFunc: Crossover function.\nmutationFunc: Mutation function.\nterminationNum: number of iteration after which the algorithm aborts if there is no change in fitness value from the best gene\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Mutation","page":"Mutation","title":"Mutation","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"The Mutation function makes random changes to the genes of individuals, mimicking the process of genetic mutation in nature. This is essential to maintain diversity in the population and introduce new genes to the population.","category":"page"},{"location":"mutation/#Mutation-Functions","page":"Mutation","title":"Mutation Functions","text":"","category":"section"},{"location":"mutation/","page":"Mutation","title":"Mutation","text":"","category":"page"},{"location":"crossover/#Crossover","page":"Crossover","title":"Crossover","text":"","category":"section"},{"location":"crossover/","page":"Crossover","title":"Crossover","text":"The Crossover function, also known as recombination, mimics the genetic recombination during natural evolution. It combines the genetic information(chromosomes) of the parents to create one or more new children. ","category":"page"},{"location":"crossover/#Crossover-Functions","page":"Crossover","title":"Crossover Functions","text":"","category":"section"},{"location":"crossover/","page":"Crossover","title":"Crossover","text":"single_point_crossover\nk_point_crossover\nuniform_crossover","category":"page"},{"location":"crossover/#GeneticAlgorithm.single_point_crossover","page":"Crossover","title":"GeneticAlgorithm.single_point_crossover","text":"single_point_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix})\n\nRecombinate two units by exchanging their genes from a random index onward.\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#GeneticAlgorithm.k_point_crossover","page":"Crossover","title":"GeneticAlgorithm.k_point_crossover","text":"k_point_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix}, k::Integer)\n\nRecombinate two units by exchanging their genes at k random points\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\nk: # of crossover points.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#GeneticAlgorithm.uniform_crossover","page":"Crossover","title":"GeneticAlgorithm.uniform_crossover","text":"uniform_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix})\n\nRecombinate two units by iterating a gene and swapping the values with a 50% chance\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"function"},{"location":"initialisation/#Initialisation","page":"Initialisation","title":"Initialisation","text":"","category":"section"},{"location":"initialisation/","page":"Initialisation","title":"Initialisation","text":"This is the starting point of a Genetic Algorithm. The Initialisation generates the initial population of individuals, which is usually generated randomly.","category":"page"},{"location":"initialisation/#Initialisation-Functions","page":"Initialisation","title":"Initialisation Functions","text":"","category":"section"},{"location":"initialisation/","page":"Initialisation","title":"Initialisation","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeneticAlgorithm","category":"page"},{"location":"#GeneticAlgorithm","page":"Home","title":"GeneticAlgorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package providing genetic algorithms for optimization. It provides diffrent implementation of mutation, recombination, crossover and selection functions. Documentation for GeneticAlgorithm.","category":"page"},{"location":"#Important","page":"Home","title":"Important","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is build for the Julia Programming for Machine Learning course at TU Berlin and will will not be maintained afterwards.","category":"page"},{"location":"#What-is-a-Genetic-Algorithm?","page":"Home","title":"What is a Genetic Algorithm?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Genetic Algorithm is a technique based on natural evolution and genetics. It solves constrained and unconstrained optimization problems in which traditional algorithms and methods might struggle. It is part of the class of evolutionary algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following chart shows the basic steps of a Genetic Algorithm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: How does a Genetic Algorithm work)","category":"page"},{"location":"#Outline-of-a-Genetic-Algorithm:","page":"Home","title":"Outline of a Genetic Algorithm:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initialisation: creates the initial population of individuals with random chromosomes\nEvaluation: evaluate the fitness of each individual using the fitness function\nSelection: select the best individuals based on their fitness score to select parents for the new generation\nCrossover: the selected parents are combined to produce offspring\nMutation: some chromosomes are mutated\nRepeat: repeat this the Evaluation, Selection, Crossover, and Mutation until a solution is found or the termination condition is met","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/MaxHTu/GeneticAlgorithm.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a simple example unsing a genetic algorithm to solve he Rosenbrock function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeneticAlgorithm\ngenAlgo(50, true, 2, rosenbrock, 50, 0.25, 0.1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"geneticAlgorithm\ngenAlgo","category":"page"},{"location":"#GeneticAlgorithm.geneticAlgorithm","page":"Home","title":"GeneticAlgorithm.geneticAlgorithm","text":"geneticAlgorithm(     popSize::Integer,     unitValues::Type,     unitShape::Integer,     fitnessFunc::Function,     genNum::Integer,     selection::Function,     crossover::Function,     mutation::Function,     crossRate::Real,     mutRate::Real,     nextGenAmt::Real,     terminationNum::Real;     initFunc::Function )\n\nEvolve the population of units for a specified number of generations. The loop creates a new population every generation by selecting units with higher fitness, recombinating and mutating them until the old population can be replaced by a fitter one.\n\nArguments\n\nfitnessFunc: Fitness function.\npopSize: Size of population.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\nselection: Selection function.\ncrossover: Crossover function.\nmutation: Mutation function.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\nnextGenAmt: amount of genes that are automatically copied to new generation\nterminationNum: number of iteration after which the algorithm aborts if there is no change in fitness value from the best gene\ninitFunc: function to generate initial population\n\n\n\n\n\n","category":"function"},{"location":"#GeneticAlgorithm.genAlgo","page":"Home","title":"GeneticAlgorithm.genAlgo","text":"genAlgo(     popSize::Integer,     unitValues::Type,     unitShape::Integer,     fitnessFunc::Function,     genNum::Integer,     selection::Function,     crossover::Function,     mutation::Function,     crossRate::Real,     mutRate::Real )\n\nTODO: description\n\nArguments\n\nfitnessFunc: Fitness function.\npopSize: Size of population.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\nselection: Selection function.\ncrossover: Crossover function.\nmutation: Mutation function.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Modules = [GeneticAlgorithm]","category":"page"},{"location":"#GeneticAlgorithm.binarystring-Tuple{AbstractVector}","page":"Home","title":"GeneticAlgorithm.binarystring","text":"binarystring(x::AbstractVector{Bool})\n\nCompute the fitness of a binary string unit.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe digit sum of input vector.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.crossoverSudoku-Tuple{Matrix{Int64}, Matrix{Int64}}","page":"Home","title":"GeneticAlgorithm.crossoverSudoku","text":"crossoverSudoku(s_1::Matrix{Int64}, s_2::Matrix{Int64})\n\nCrosses 2 given sudokus row wise at a randomly generated row index.\n\nArguments\n\ns_1: first filled out sudoku\ns_2: second filled out sudoku\n\nReturns\n\n2 altered sudokus\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.default_selection-Tuple{Union{AbstractMatrix, AbstractVector}, Integer}","page":"Home","title":"GeneticAlgorithm.default_selection","text":"default_selection(population::Union{AbstractVector,AbstractMatrix}, num::Integer)\n\nSelects a specified number of individuals from a population.\n\nArguments\n\npopulation: The population from which individuals will be selected.\nnum: The number of individuals to select.\n\nReturns\n\nAn array of selected individuals.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.fitness-Tuple{Matrix{Int64}, Matrix{Int64}}","page":"Home","title":"GeneticAlgorithm.fitness","text":"fitness(genome::Matrix{Int64}, sudoku::Matrix{Int64})\n\nEvaluates the fitness of a given genome and the base sudoku. Starting from 0 a genome gets 10 points for each correctly filled column (reminder the rows are filled per definition by the initialization function) and each 3x3 box. 2 points are deducted for each value that cannot be in this column or box because of the values in the base sudoku.\n\nArguments\n\ngenome: filled out sudoku to be evaluated\ns: Base sudoku\n\nReturns\n\nA fitness value\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.genAlgo-Tuple{Function, Integer, Union{Type, AbstractVector{<:Real}}, AbstractVector{<:Integer}, Integer, Function, Function, Function, Vararg{Real, 4}}","page":"Home","title":"GeneticAlgorithm.genAlgo","text":"genAlgo(     popSize::Integer,     unitValues::Type,     unitShape::Integer,     fitnessFunc::Function,     genNum::Integer,     selection::Function,     crossover::Function,     mutation::Function,     crossRate::Real,     mutRate::Real )\n\nTODO: description\n\nArguments\n\nfitnessFunc: Fitness function.\npopSize: Size of population.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\nselection: Selection function.\ncrossover: Crossover function.\nmutation: Mutation function.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.generatePopulation-Tuple{Int64, Matrix{Int64}}","page":"Home","title":"GeneticAlgorithm.generatePopulation","text":"generatePopulation(n::Int, s::Matrix{Int64})\n\nGenerate an array of n filled out sudokus\n\nArguments\n\nn: size of the population\ns: Given sudoku with zeros\n\nReturns\n\nArray of n possible Sudoku solutions without zeros\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.geneticAlgorithm-Tuple{Function, Integer, Union{Type, AbstractVector{<:Real}}, AbstractVector{<:Integer}, Integer, Function, Function, Function, Vararg{Real, 4}}","page":"Home","title":"GeneticAlgorithm.geneticAlgorithm","text":"geneticAlgorithm(     popSize::Integer,     unitValues::Type,     unitShape::Integer,     fitnessFunc::Function,     genNum::Integer,     selection::Function,     crossover::Function,     mutation::Function,     crossRate::Real,     mutRate::Real,     nextGenAmt::Real,     terminationNum::Real;     initFunc::Function )\n\nEvolve the population of units for a specified number of generations. The loop creates a new population every generation by selecting units with higher fitness, recombinating and mutating them until the old population can be replaced by a fitter one.\n\nArguments\n\nfitnessFunc: Fitness function.\npopSize: Size of population.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\nselection: Selection function.\ncrossover: Crossover function.\nmutation: Mutation function.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\nnextGenAmt: amount of genes that are automatically copied to new generation\nterminationNum: number of iteration after which the algorithm aborts if there is no change in fitness value from the best gene\ninitFunc: function to generate initial population\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.griewank-Tuple{AbstractVector{<:Number}}","page":"Home","title":"GeneticAlgorithm.griewank","text":"griewank(x::AbstractVector{<:Number})\n\nCompute the Griewank function value for a given input vector x.\n\nThe Griewank function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as the difference between two terms: the sum of the squares of each element in x divided by 4000, and the product of the cosine of each element in x divided by the square root of its index.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Griewank function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.initialState-Tuple{Matrix{Int64}}","page":"Home","title":"GeneticAlgorithm.initialState","text":"initialState(s::Matrix{Int64})\n\nGenerate a filled out sudoku (without zeros) from given base sudoku (with zeros). The sudoku is filled so that all the rows are already properly filled. If possible the function tries to also fill the columns and boxes properly.\n\nArguments\n\ns: Given sudoku with zeros\n\nReturns\n\nSudoku without zeros\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.k_point_crossover-Tuple{Union{AbstractMatrix, AbstractVector}, Union{AbstractMatrix, AbstractVector}, Integer}","page":"Home","title":"GeneticAlgorithm.k_point_crossover","text":"k_point_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix}, k::Integer)\n\nRecombinate two units by exchanging their genes at k random points\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\nk: # of crossover points.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.mutation!-Tuple{Union{AbstractMatrix{<:Real}, AbstractVector{<:Real}}, Real, Union{Type, AbstractVector{<:Real}}}","page":"Home","title":"GeneticAlgorithm.mutation!","text":"mutation!(gene, mutation_prob, unitValues)\n\nMutates the given gene based on the mutation_prob and unitValues.\n\nArguments\n\ngene: A matrix or vector containing real numbers or boolean values.\nmutation_prob: The probability of mutation for each element in the gene.\nunitValues: A type or vector representing the range of values for mutation.\n\nDetails\n\nFor each element in the gene, if a random number is less than mutation_prob, the element is mutated.\nIf unitValues is an abstract range of floating-point numbers, the mutated element is transformed to fit within the range.\nIf unitValues is a vector of boolean values, the mutated element is negated.\nOtherwise, the mutated element is replaced with a random value from unitValues.\n\nReturns\n\nThe mutated gene.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.quartic-Tuple{AbstractVector{<:Number}}","page":"Home","title":"GeneticAlgorithm.quartic","text":"quartic(x::AbstractVector{<:Number})\n\nCompute the quartic function value for a given input vector x.\n\nThe quartic function is defined as the sum of the product of each element in x raised to the power of 4 and its index, plus a random number.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe quartic function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.rastrigin-Tuple{AbstractVector{<:Number}}","page":"Home","title":"GeneticAlgorithm.rastrigin","text":"rastrigin(x::AbstractVector{<:Number})\n\nCompute the Rastrigin function value for a given input vector x.\n\nThe Rastrigin function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as a sum of terms involving the square of each element in x, minus 10 times the cosine of 2π times each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Rastrigin function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.rosenbrock-Tuple{Vector{<:Number}}","page":"Home","title":"GeneticAlgorithm.rosenbrock","text":"rosenbrock(x::Vector{<:Number}; a::Integer, b::Integer)\n\nCompute the Rosenbrock function value for a given input vector x.\n\nThe Rosenbrock function is a non-convex function used as a performance test problem for optimization algorithms. It is defined as the sum of a series of terms involving the squares of differences between adjacent elements of x.\n\nArguments\n\nx: Input vector.\na: value for the variable a\nb: value for the variable b\n\nReturns\n\nThe Rosenbrock function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.schwefel-Tuple{AbstractVector{<:Number}}","page":"Home","title":"GeneticAlgorithm.schwefel","text":"schwefel(x::AbstractVector{<:Number})\n\nCompute the Schwefel function value for a given input vector x.\n\nThe Schwefel function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as a sum of terms involving the sine function and the square root of the absolute value of each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Schwefel function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.single_point_crossover-Tuple{Union{AbstractMatrix, AbstractVector}, Union{AbstractMatrix, AbstractVector}}","page":"Home","title":"GeneticAlgorithm.single_point_crossover","text":"single_point_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix})\n\nRecombinate two units by exchanging their genes from a random index onward.\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.solveRosenbrock-Tuple{}","page":"Home","title":"GeneticAlgorithm.solveRosenbrock","text":"solveRosenbrock(;     a::Integer,     b::Integer,     popSize::Integer,     fitnessFunc::Function,     unitValues::Union{Type, AbstractVector{<:AbstractFloat}, AbstractRange{<:Real}},     unitShape::AbstractVector{<:Integer},     genNum::Integer,     crossRate::Real,     mutRate::Real,     nextGenAmt::Number,     selectionFunc::Function,     crossoverFunc::Function,     mutationFunc::Function ,     terminationNum::Real )\n\nRuns the rosenbrock function with the geneticAlgorithm\n\nArguments\n\na: rosenbrock function variable\nb: rosenbrock function variable\npopSize: Size of population.\nfitnessFunc: Fitness function.\nunitValues: Type of unit.\nunitShape: Length of a unit vector.\ngenNum: Number of generations.\ncrossRate: Crossover rate.\nmutRate: Mutation rate.\nnextGenAmt: amount of genes that are automatically copied to new generation\nselectionFunc: Selection function.\ncrossoverFunc: Crossover function.\nmutationFunc: Mutation function.\nterminationNum: number of iteration after which the algorithm aborts if there is no change in fitness value from the best gene\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.sphere-Tuple{Vector{<:Number}}","page":"Home","title":"GeneticAlgorithm.sphere","text":"sphere(x::Vector{<:Number})\n\nCompute the sphere function value for a given input vector x.\n\nThe sphere function is defined as the sum of the squares of each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe sphere function value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.sudokuMutation","page":"Home","title":"GeneticAlgorithm.sudokuMutation","text":"sudokuMutation(o::Matrix{Int64}, sudoku::Matrix{Int64},  probability=0.2)\n\nGo through all the rows of a sudoku and if a random value is larger than a probability, swap 2 values in that row\n\nArguments\n\no: sudoku to be mutated\nsudoku: base sudoku\nprobability: probability with which we mutate a row\n\nReturns\n\na mutated sudoku\n\n\n\n\n\n","category":"function"},{"location":"#GeneticAlgorithm.tournament_selection-Tuple{AbstractVector, AbstractVector, Integer}","page":"Home","title":"GeneticAlgorithm.tournament_selection","text":"tournament_selection(population::Vector, fitness::Vector, tournamentSize::Int, num::Integer)\n\nSelect one unit with higher fitness over several tournament rounds with randomly chosen groups of unit from the population .\n\nArguments\n\npopulation: Population vector.\nfitness: Vector of fitness values.\ntournamentSize: Size of tournament groups.\nnum: Amount of genes to select\n\nReturns\n\nThe unit with better fitness value.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.uniformCrossover-Tuple{Matrix{Int64}, Matrix{Int64}}","page":"Home","title":"GeneticAlgorithm.uniformCrossover","text":"uniformCrossover(s_1::Matrix{Int64}, s_2::Matrix{Int64})\n\nCrosses 2 given sudokus row wise by generating a random value that indicates if the current row of both sudokus should be changed between them\n\nArguments\n\ns_1: first filled out sudoku\ns_2: second filled out sudoku\n\nReturns\n\n2 altered sudokus\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.uniform_crossover-Tuple{Union{AbstractMatrix, AbstractVector}, Union{AbstractMatrix, AbstractVector}}","page":"Home","title":"GeneticAlgorithm.uniform_crossover","text":"uniform_crossover(gene1::Union{AbstractVector, AbstractMatrix}, gene2::Union{AbstractVector, AbstractMatrix})\n\nRecombinate two units by iterating a gene and swapping the values with a 50% chance\n\nArguments\n\ngene1: Parent unit 1.\ngene2: Parent unit 2.\n\nReturns\n\nTwo recombined child units.\n\n\n\n\n\n","category":"method"},{"location":"#GeneticAlgorithm.weighted_selection-Tuple{AbstractVector, AbstractVector, Integer}","page":"Home","title":"GeneticAlgorithm.weighted_selection","text":"weighted_selection(population::AbstractVector, fitness::AbstractVector, num::Integer)\n\nSelect num random genes from population weight by the fitness of the genes\n\nArguments\n\npopulation: Population vector.\nfitness: Vector of fitness values.\nnum: Amount of genes to select\n\nReturns\n\nnum selected genes\n\n\n\n\n\n","category":"method"},{"location":"evaluation/#Evaluation","page":"Evaluation","title":"Evaluation","text":"","category":"section"},{"location":"evaluation/","page":"Evaluation","title":"Evaluation","text":"This file contains a collection of common optimization test functions implemented in Julia to test the performance of the Genetic Algorithm. The functions are based on the paper ON BENCHMARKING FUNCTIONS FOR GENETIC ALGORITHMS.","category":"page"},{"location":"evaluation/#Evaluation-Functions","page":"Evaluation","title":"Evaluation Functions","text":"","category":"section"},{"location":"evaluation/","page":"Evaluation","title":"Evaluation","text":"sphere\nrosenbrock\nquartic\nschwefel\nrastrigin\ngriewank\nbinarystring","category":"page"},{"location":"evaluation/#GeneticAlgorithm.sphere","page":"Evaluation","title":"GeneticAlgorithm.sphere","text":"sphere(x::Vector{<:Number})\n\nCompute the sphere function value for a given input vector x.\n\nThe sphere function is defined as the sum of the squares of each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe sphere function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.rosenbrock","page":"Evaluation","title":"GeneticAlgorithm.rosenbrock","text":"rosenbrock(x::Vector{<:Number}; a::Integer, b::Integer)\n\nCompute the Rosenbrock function value for a given input vector x.\n\nThe Rosenbrock function is a non-convex function used as a performance test problem for optimization algorithms. It is defined as the sum of a series of terms involving the squares of differences between adjacent elements of x.\n\nArguments\n\nx: Input vector.\na: value for the variable a\nb: value for the variable b\n\nReturns\n\nThe Rosenbrock function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.quartic","page":"Evaluation","title":"GeneticAlgorithm.quartic","text":"quartic(x::AbstractVector{<:Number})\n\nCompute the quartic function value for a given input vector x.\n\nThe quartic function is defined as the sum of the product of each element in x raised to the power of 4 and its index, plus a random number.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe quartic function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.schwefel","page":"Evaluation","title":"GeneticAlgorithm.schwefel","text":"schwefel(x::AbstractVector{<:Number})\n\nCompute the Schwefel function value for a given input vector x.\n\nThe Schwefel function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as a sum of terms involving the sine function and the square root of the absolute value of each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Schwefel function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.rastrigin","page":"Evaluation","title":"GeneticAlgorithm.rastrigin","text":"rastrigin(x::AbstractVector{<:Number})\n\nCompute the Rastrigin function value for a given input vector x.\n\nThe Rastrigin function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as a sum of terms involving the square of each element in x, minus 10 times the cosine of 2π times each element in x.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Rastrigin function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.griewank","page":"Evaluation","title":"GeneticAlgorithm.griewank","text":"griewank(x::AbstractVector{<:Number})\n\nCompute the Griewank function value for a given input vector x.\n\nThe Griewank function is a multimodal function used as a performance test problem for optimization algorithms. It is defined as the difference between two terms: the sum of the squares of each element in x divided by 4000, and the product of the cosine of each element in x divided by the square root of its index.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe Griewank function value.\n\n\n\n\n\n","category":"function"},{"location":"evaluation/#GeneticAlgorithm.binarystring","page":"Evaluation","title":"GeneticAlgorithm.binarystring","text":"binarystring(x::AbstractVector{Bool})\n\nCompute the fitness of a binary string unit.\n\nArguments\n\nx: Input vector.\n\nReturns\n\nThe digit sum of input vector.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To show how this package can be used, we use some of the predefined fitness functions and use the API. First it is important to use the package to get access to the function API.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeneticAlgorithm","category":"page"},{"location":"tutorial/#Examples","page":"Tutorial","title":"Examples","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Simple examples of using the genAlgo function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Find maximum of binarystring function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# with default values\ngenAlgo(binarystring)\n# with set named optional variables\ngenAlgo(binarystring, genNum=100)\n# with own provided optional crossover function\ngenAlgo(binarystring, crossover=(x,y) -> k_point_crossover(x,y,10))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Find maximum of griewank function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# with default values\ngenAlgo(griewank)\n# with set named optional variables\ngenAlgo(griewank, unitValues=-1000.0:1000.0, genNum=500, mutRate=0.25)\n# with own provided optional selection function\ngenAlgo(griewank, selection=(a,b,c)->GeneticAlgorithm.weighted_selection(a,b,c))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Find maximum of rastrigin function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# with default values\ngenAlgo(rastrigin)\n# with set named optional variables\ngenAlgo(rastrigin, mutRate=0.75, crossRate=1, genNum=1000)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Find maximum of rosenbrock function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# with set named optional variables\nsolveRosenbrock(a=4,b=100,genNum=100, mutRate=0.1, unitShape=[3], popSize=11)\n# with set named optional variables\nsolveRosenbrock(a=4,b=100,genNum=250, mutRate=0.25, unitShape=[2], popSize=500, unitValues=-1000.0:1000.0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Solve Sudoku:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"s = [0 0 0 8 2 0 0 9 0;0 5 7 6 0 9 0 1 3;0 8 4 0 3 1 0 0 0;0 7 8 0 6 0 4 5 0;0 0 9 1 0 0 0 0 6;5 6 0 3 0 0 9 8 0;8 3 0 4 0 6 0 0 0;0 0 5 0 1 8 0 0 0;1 0 6 7 5 0 2 0 0]\nsolveSudoku(s, genNum=250)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can also use own fitness functions:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Maximize trace of a matrix between the values 0 and 723:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"genAlgo(x -> tr(x), unitValues=0:723, popSize=10, mutRate=0.5, unitShape=[2,2], crossRate=0.8)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Find matrix with det = 0 <=> flip fitness score so desired output has highest value:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function f(x)\n    return det(x) >= 1000 ? 0.0001 : 1000-abs(det(x))\nend\n\ngenAlgo(x -> f(x), unitValues=0:723, popSize=10, mutRate=0.5, unitShape=[2,2], crossRate=0.8, genNum=1000)","category":"page"}]
}
